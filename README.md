3D-Image-Viewer
===============

Basic 3D image viewer i created for a project

DOCUMENTATION:  
1. The first part of this project was to read the points and polygons from the file into two arrays. I read the first line of the file, which contained the # of points and the # of polygons, and parsed it to create two lists of respective lengths to the parsed numbers.  
	a) With the first list, the list of points, I read line by line from the file, splitting each line by spaces into an array of x, y and z points, and then inserted this 3 element array into the points array. This was repeated for lines to # of points gotten from the first line.  
	b) The second list was created nearly the same way, reading line by line, and splitting each line into arrays by spaces. However, the first element in each of these separated arrays was the length of the array, so I was removed this before inserting the array of points into the polygon array. Because the file had polygons of differing array lengths, I had to make my array of polygons an Arraylist, because only a list could hold arrays of differing sizes. A 2d array would have to have been created with the 2nd dimension of length the maximum polygon point array length, which would not only have left numerous empty spaces, would require going over the input file twice to find said maximum polygon point length.  
2. Next, I sorted the arraylist of polygons by z value. I wrote a method that took an array of points (the ones stored in the polygon array), and averaged the z values of every point's z value in it. Using this, I could compare two polygons z values. I implemented 2 types of sorts.  
	a) I implemented quicksort recursively, picking a pivot point of the middle of the list (I choose the middle point as a pivot to prevent the worst case O(n2) in an already sorted list, because in a case where the input list is sorted, picking the middle as a pivot generated a best case perfect split list. In a case where the input list is random, picking the middle has the same change as picking the median value of all the numbers as picking a random index, and getting the average case of O(n*log(n)) This makes the worst case scenario now if the list is sorted but the first or last element start in the middle, an scenario which should never be encountered). Using the pivot as a comparator, I moved lesser elements to one list, and greater elements to another list, and then recursively called quicksort for moth lists. This recursion finished when the list was length 1 or less, and unrecursed adding each lesser, pivot, and greater to the final, sorted list.  
	a) My next sort, MergeSort, was also implemented recursively. I split the input list into halves, and then recursed with each of these two lists. When the list length was 1 or less, I returned and merged the two lists by basic insertion sort. I did this in a loop, checking if 1 or the other lists became 0, and if they did, I short circuited and added all the elements from the still full list on the top of the final list. I then returned this combined list, and un-recursed.  
3. I also implemented a number of user controls to manipulate the shape.  
	a) The option to rotate the shape, so that when the user pressed an arrow key I would iterate though all the points in the points array, and rotated it (see algorithms in method rotate()) by a number of degrees (5, specifically). Next, having edited all the points and their values, since the z values had changed, I re-sorted the list of polygons.  
	b) The option to move the shape along the x y or z axis (moves up/down, left/right, and zooms, respectively). I simply instantiated 3 global variables for each axis, and when the user pressed a key I offset the respective variable by an amount. Then, upon drawing the image, when the points were flattened I added the offset to each axis.  
4. Finally, I drew the shape by iterating though the sorted list of polygons bottom up, converting the x and y points of each point in the polygon to 2d coordinates, adding each x point in a polygon's point list to 1 array, and adding the y points in the polygon's point list to a y array. While doing this, I also added up each point's z value, and averaged it. I then converted this z value to a 255 range (divided by 2, the max value and multiplied by 255), and used this as a greyscale RGB value for the polygon. I then used java's drawpolygon() function, supplying it with the xpoint array, y point array, number of points in the polygon, and color. It then connected each x and y point to the next (including first and last), and drew the colored polygon. From here, the user can further rotate the shape (goto point 3), or close the program.
